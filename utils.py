# encoding=gb18030
import datetime
import linecache
import logging
import os
import shlex
import subprocess
import time

# 获取目录下的所有文件夹和文件
import sys

import shutil

import constant


def get_files(path):
    global allFileNum

    # 所有文件夹，第一个字段是次目录的级别
    dirList = []
    # 所有文件
    fileList = []
    # 返回一个列表，其中包含在目录条目的名称(google翻译)
    files = os.listdir(path)
    for f in files:
        if (os.path.isdir(path + '/' + f)):
            # 排除隐藏文件夹。因为隐藏文件夹过多
            if (f[0] == '.'):
                pass
            else:
                # 添加非隐藏文件夹
                dirList.append(f)
        if (os.path.isfile(path + '/' + f)):
            # 添加文件
            fileList.append(path + '/' + f)
    # 当一个标志使用，文件夹列表第一个级别不打印
    i_dl = 0
    for dl in dirList:
        if (i_dl == 0):
            i_dl = i_dl + 1
    return fileList, dirList
    # for fl in fileList:
    #     # 打印文件
    #     print '-' * (int(dirList[0])), fl
    #     # 随便计算一下有多少个文件
    #     allFileNum = allFileNum + 1


# 创建logger
def get_logger(log_file_name):
    # 创建一个logger
    logger = logging.getLogger(log_file_name)
    logger.setLevel(logging.DEBUG)
    # 创建一个handler，用于写入日志文件
    fh = logging.FileHandler(log_file_name + ".log")
    fh.setLevel(logging.DEBUG)
    # 再创建一个handler，用于输出到控制台
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    # 定义handler的输出格式
    formatter = logging.Formatter('%(asctime)s - %(message)s')
    fh.setFormatter(formatter)
    ch.setFormatter(formatter)
    # 给logger添加handler
    logger.addHandler(fh)
    logger.addHandler(ch)
    return logger


# 执行脚本命令
def execute_command(cmdstring, cwd=None, timeout=None, shell=False):
    """执行一个SHELL命令
            封装了subprocess的Popen方法, 支持超时判断，支持读取stdout和stderr
           参数:
        cwd: 运行命令时更改路径，如果被设定，子进程会直接先更改当前路径到cwd
        timeout: 超时时间，秒，支持小数，精度0.1秒
        shell: 是否通过shell运行
    Returns: return_code
    Raises:  Exception: 执行超时
    """
    if shell:
        cmdstring_list = cmdstring
    else:
        cmdstring_list = shlex.split(cmdstring)
    if timeout:
        end_time = datetime.datetime.now() + datetime.timedelta(seconds=timeout)

    # 没有指定标准输出和错误输出的管道，因此会打印到屏幕上；
    sub = subprocess.Popen(cmdstring_list, cwd=cwd, stdout=None, shell=shell, bufsize=1)

    # subprocess.poll()方法：检查子进程是否结束了，如果结束了，设定并返回码，放在subprocess.returncode变量中
    while sub.poll() is None:
        time.sleep(0.1)
        if timeout:
            if end_time <= datetime.datetime.now():
                raise Exception("Timeout：%s" % cmdstring)
    return str(sub.returncode)


def print_exception():
    exc_type, exc_obj, tb = sys.exc_info()
    f = tb.tb_frame
    lineno = tb.tb_lineno
    filename = f.f_code.co_filename
    linecache.checkcache(filename)
    line = linecache.getline(filename, lineno, f.f_globals)

    exception = 'EXCEPTION IN ({}, LINE {} "{}"): {}'.format(filename, lineno, line.strip(), exc_obj)
    print(exception)
    return exception


def get_shell_output(cmd):
    process = os.popen(cmd)  # return file
    output = process.readlines()
    return output


def del_dir(path):
    cmd = "ls -lt " + path + " | awk '{print $9}'"
    infos = get_shell_output(cmd)
    dir_names = []
    for info in infos:
        if info and '_' in info:
            fields = info.split('_')
            dir_names.append(int(fields[0]))
    dir_names.sort(reverse=True)
    dir_paths = [path + str(name) + "*" for name in dir_names[3:]]
    rm_dir = 'rm -rf ' + ' '.join(dir_paths)
    execute_command(rm_dir, shell=True)


def rm_mkdir(path, source):
    if source == constant.local_sign:
        if os.path.exists(path):
            shutil.rmtree(path)
        os.makedirs(path)
    else:
        rm_commond = "hadoop fs -rm -r " + path
        execute_command(rm_commond, shell=True)
        mkdir_commond = "hadoop fs -mkdir " + path
        execute_command(mkdir_commond, shell=True)
